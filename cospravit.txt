Ked nejde git push, skus v terminaly AS:
git config credential.helper store

--------------------------------
Hadanie warningov v kode:
Toto hladaj:
@SuppressLint
@SuppressWarnings
//noinspection

--------------------------------

Preco uz nie je PPP v GPlay:

Google restrictions:
1. Android - All Wi-Fi related functions not working since Android 10.
2. Google Play - Google require (currently) Android 10+ for applications. In application exists gradle configuration parameter:
    targetSdkVersion targetSdk
  and in PPP must be target sdk = 28. Android 10 is 29.

In stores, in which is currently deployed PPP, restriction about target sdk not exists.

----------------------------------------

indicator color and its complementary color:
dark tema: indicator:62a9f8 -> accent:f8b162 -> event delay:#F862F4
light tema: indicator:4289d8 -> accent:cc893e -> event delay:#D842D4

https://www.canva.com/colors/color-wheel/

------------------------

Widget Preview Builder:
https://play.google.com/store/apps/details?id=lav.widgetpreviewbuilder.free&hl=en_US&gl=US

------------------------
funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
------------------------

Ulohy, ktore su spravene [x] a ktore nie [ ]:
[ ] Priority Notification Event
[ ] Normal media volume, headphone media volume, Bluetooth media volume
[ ] Sony's "Stamina" mode as profile preference - skor Power save change senzor
[ ] USB connection to PC as storage device, USB connection to PC as camera, connection to USB stick in accessories parameter for events
[ ] option to hide PPP from Launcher
[ ] Set min and max CPU frequency
[ ] Open a website with profile
[ ] profile/event search
[ ] Persistent profile/event: sets its options every x minutes - asi periodic sensor
[ ] Android Wear support?
[ ] (AND, OR, XOR, NOT. Or at least NOT.)<-NOT is already available in most preferences. If that stays, that does the same.
[ ] a plugin system? (very small core app, ability to install additional event preferences, maybe only time event preinstalled)

------------------------

UNDO:
=====

Na "Undo profile" sa pouziva FIFO, je to vlastne zoznam profilov a udalosti v poradi, v akom sa aktivovali, spustili.

1. DataWrapper.fifoAddProfile()

PhoneProfilesService.doFirstStart() - PPApplication.prefLastActivatedProfle, 0
DataWrapper._activateProfile() - profileId (ktory sa aktivuje), 0
DataWrapper.activateProfileFromEvent() - profieId, event_id
Event.startEvent() - profileId, _id - ked nejde o merge profilov a nie je to manualna aktivacia z udalosti
Event.doActivateEndProfile() - profileId, _id - ked nejde o merge profilov a nie je to manualna aktivacia z udalosti

koniec udalosti, nie je manualne aktivovany profil:
EventsHandler.handleEvents() - defaultProfile, 0 - ak ide o aktivaciu default profilu, je nakonfigurovany
EventsHandler.handleEvents() - PPApplication.prefLastActivatedProfile, 0 - ak nie je nakonfigurovany default profile

koniec udalosti, je manualne aktivovany profil:
EventsHandler.handleEvents() - semiOldActivatedProfileId, 0 - ak je aktivovany daky profil
EventsHandler.handleEvents() - defaultProfile, 0 - ak nie je aktivovany daky profil a ide o aktivaciu default profilu, je nakonfigurovany
EventsHandler.handleEvents() - PPApplication.prefLastActivatedProfile, 0 - ak nie je aktivovany daky profil a nie je nakonfigurovany default profile

2. DataWrapper.fifoSaveProfiles()

DataWrapper.activateProfile() - pre STARTUP_SOURCE_FOR_FIRST_START - vyprazdni FIFO
EditorProfileListFragment.deleteProfile() - vymaze vymazavany profil z FIFO
EditorProfileListFragment.deleteAllProfiles() - vyprazdnenie FIFO
EventHlandler.handleEvents() - vyprazdnenie FIFO pri starte udalosti pred spustanim udalosti
PhoneProfilesService.doForFirstStart() - vyprazdnenie FIFO na prvy start, potom hned nasleduje pridanie PPApplication.prefLastActivatedProfile
PPApplication._exitApp() - vyprazdnenie FIFO na ukoncenie PPP


Ako sa robi UNDO:

Event.doActivateEndProfile() - ak je EATENDDO_UNDONE_PROFILE - pre merge an non-merge profiles
- Spravi sa zonznam FIFO udalosti, ktore nie su rovne ukoncovanej udalosti.
  Profily z ukoncovanej udalosti nas uz nezaujimaju, vsetky sa z FIFO vymazu.
- Z novovzniknuteho FIFO sa vezme posledny profil a ten sa aktivuje

ProfileDurationAlarmBroadcastReceiver._doWork() - ak je AFTER_DURATION_DO_UNDO_PROFILE
- Vymaze sa posledny profil z FIFO, j jedno, ci ma priradenu udalost
- Potom za z FIFO vezme posledny profil a ten sa aktivuje

------------------------

System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled

Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

NFC tag senzor - NEFUNGUJE PRI CITANI TAGU NA POZADI!

ZE BY UZ OPRAVENE? DLHO SA NIKTO NESTAZOVAL.

Tu mas ako sa to id cita: https://gist.github.com/luixal/5768921.

- Sprav aby to len citalo UID a to pouzivaj na identifikaciu tagu.
  Takto precitas UID: https://gist.github.com/luixal/5768921
- Na nacitanie tagu v NFCTagPreference sa vytvori nova aktivita NFCTagReadEditorActivity.
  Ta bude normalna ako je teraz NFCTagWritreActivity, ktoru zahodim.
  Zobrazovat bude precitane UID tagu a aj jeho obsah.
  Aj citanie by malo zacat automaticky, ked prilozim tag ku mobilu.
- Pridanie tagu nech hned vyvola citanie UID
- Write to tag polozku menu tagu zrus a zamen za citanir UID tagu
- Premenovanie tagu teraz je nahovno, nespravi aj zapis dso tagu, ale po novom to bude OK ako to je.
- V tabulke TABLE_NFC_TAGS pribudne polozka KEY_NT_UID = "uid". Tam sa zapise precitane uid.
- Aby bola spatna kompatibilita so starymi tagmi, bude NFCTagReadActivity citat uid aj obsah tagu.
  Ak bude uid v tabulke KEY_NT_UID prazdne, pouzije sa ako teraz obsah tagu. Inac sa pouzije uid tagu.
- Pre NFCTagReadActivity zmenit v manifeste intent filter na tento:
    <intent-filter>
        <action android:name="android.nfc.action.TAG_DISCOVERED"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>

----------------------

Direct boot:
- Asi nemozem spravit, nepodporuje to WorkManager. :-(
- toto je super na to, aby sa PPP startol aj pri uzamknutej obrazovke.
- android.intent.action.LOCKED_BOOT_COMPLETED vid:
    https://medium.com/@jordan_shifter/direct-boot-on-android-nougat-71f06c4a7c9e
- Ak nepuzijes direct boot, tak apka pada napr. v Fabric, android_job.
  To preto, lebo chcu pouzivat shared preferences a v uzamknutej obrazovke bez direct boot
  to spadne na IllegalStateException.

  Fabric, android-job uz nepouzivam, treba testnut s Firebase Crashlytics a WorkManager

- Ako spravit podporu Direct boot:
    https://developer.android.com/training/articles/direct-boot

- Len mam taky strasne blby pocit, ze neviem ako movnut shared preferences z device do credential storage.
  Vid:
    https://developer.android.com/reference/android/content/Context#moveSharedPreferencesFrom(android.content.Context,%20java.lang.String)
    https://developer.android.com/reference/android/content/Context#moveDatabaseFrom(android.content.Context,%20java.lang.String)
  Alebo, ze by pomohlo toto?
    https://stackoverflow.com/questions/51377089/android-crashlytics-fails-on-direct-boot-due-to-disk-encryption


--------------

Start udalosti:
1. Start s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_START a NENASTAVI event._status na ESTATUS_RUNNING, necha ho ESTATUS_PAUSE
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayStart je uz false. Az tu vola startEvemt(), cize nastavi ESTATUS_RUNNING.
Vysledok je, ze pocas delay je stale PAUSE az po delay je RUNNING.

Koniec udalosti:
1. Koniec s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_END a NENASTAVI event._status na ESTATUS_PAUSE, necha ho ESTATUS_RUNNING
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayEnd je uz false. Az tu vola pauseEvemt(), cize nastavi ESTATUS_PAUSE.
Vysledok je, ze pocas delay je stale RUNNING az po delay je PAUSE.

-----------------

Battery historian:
1. sudo apt install docker.io
2. Ako pouzivat: https://developer.android.com/topic/performance/power/setup-battery-historian
3. Spustaj ale takto:
      sudo docker run -p 20000:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999
4. V Chrome potom: http://localhost:20000

------------------

mám funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
třeba se to bude hodit.

-------------------------

ActivateProfileHelper.setScreenTimeout()
- disableScreenTimeoutInternalChange = true;
- pre kazdy timeout z parametra:
	if (PPApplication.lockDeviceActivity != null)
	    // in LockDeviceActivity.onDestroy() will be used this value to revert back system screen timeout
	    PPApplication.screenTimeoutBeforeDeviceLock = 15000;
	else {
      	    Settings.System.putInt(appContext.getContentResolver(), Settings.System.SCREEN_OFF_TIMEOUT, xxx);
      	}
- nerobi 6, 8. Preco?
- zavola:
        setActivatedProfileScreenTimeout(appContext, 0);
- zavola work:
	DisableScreenTimeoutInternalChangeWorker.class

- volane z:
  - ActivateProfileHelper.execute() - aktivacia profilu ak je obrazovka zapnuta
  - LockDeviceActivity.onDestroy() - na nastavenie timeoutu, ak sa este nenastavil
  - ScreenOnOffBroadcastReceiver.onReceive() na ACTION_USER_PRESENT

ActivateProfileHelper.setActivatedProfileScreenTimeout()
- ulozi do shared preferences timeout.
- ulozi to aj do ApplicationPreferences.prefActivatedProfileScreenTimeout
- pouzije to v ScreenOnOffBroadcastReceiver.onReceive() na ACTION_USER_PRESENT
- pouzije to aj v LockDeviceActivity.onDestroy() na vratenie timeoutu

- volane je z:
  - ActivateProfileHelper.setScreenTimeout() - nastavi 0, lebo netreba nastavovat na screen On ACTION_USER_PRESENT
  - ActivateProfileHelper.execute - nastavi profile parameter _deviceScreenTimeout, ak je screen off
  - SettingsContentObserver.onChange() - nastvi 0 ak posledny zapamatany timeout je iny ako aktualny. a  nie je to internalChange
                                                  ActivateProfileHelper.disableScreenTimeoutInternalChange
                                         to aby sa nepouzila na ten screen On ACTION_USER_PRESENT. Tu sa predpoklada, ze zmena prisla z vonka.

premenna PPApplication.screenTimeoutBeforeDeviceLock:
- tu si pamatam, aky timeout je pred spustenim LockDeviceActivity.
- na onCreate() ho zistuje
- na onDestroy() nastavi spat timeout na tuto odpamatanu hodnotu
- na onDestroy() potom nastavi timeot na hodnotu ApplicationPreferences.prefActivatedProfileScreenTimeout.


Takto sa nastavuje tiemout pri aktivacii profilu:
        // screen timeout
        if (Permissions.checkProfileScreenTimeout(appContext, profile, null)) {
            if (PPApplication.isScreenOn) {
                if (PPApplication.screenTimeoutHandler != null) {
                    PPApplication.screenTimeoutHandler.post(() -> {
                        setScreenTimeout(profile._deviceScreenTimeout, appContext);
                    });
            }
            else {
                setActivatedProfileScreenTimeout(appContext, profile._deviceScreenTimeout);
            }
        }
- cize ak je screen on, nastavi sa timeount hned.
- ak je screen off, nastavi sa timeount az v ScreenOnOffBroadcastReceiver.onReceive() na ACTION_USER_PRESENT
  cize len sa hodnota ulozi do ApplicationPreferences.prefActivatedProfileScreenTimeout.
Toto cele chapem.

-----------------------

Zmena hlasitosti profilom:

Toto su parametre:
forRingerMode -> true, ak menim aj ringer mod?
- ak profil meni ringer mod, ton zvonenia, notifikacie, systemu, DTMF, tak je true
- inac je false
forProfileActivation -> true ak volam pre aktivaciu profilu?
- ak je volane z ActivateProfileHelper.execute(), je true, cize ano ide o aktivaciu profilu
- ak je volane z PhoneCallListener.setLinkUnlinkNotificationVolume() je false, cize je to pocas hovoru
  aby sa vykonal unlink.

setRingerVolume(appContext, profile.getVolumeRingtoneValue()); -> pozri co za premennu to nastavuje
- ApplicationPreferences.prefRingerVolume
  meni sa pri starte PPP, pri aktivacii profilu, pri zmene hlasitosti zvonenia v systeme
setNotificationVolume(appContext, profile.getVolumeNotificationValue()); -> pozri co za premennu to nastavuje
- ApplicationPreferences.prefNotificationVolume
  meni sa pri starte PPP, pri aktivacii profilu, pri zmene hlasitosti notifikacii v systeme
  meni sa aj na hlaitost zvonenia pri unlinku, podla mna preto, lebo v podstate je len 1 volume
  pri zmerovananych hlasitostiach, tak nech su rovnake.

-> Len ak je system ringer mode audible, alebo ak ApplicationPreferences.prefRingerMode=0
-> ringerMode == 0 znamena, ze je nenastaveny. Ide o ringer mod podla Profile.RINGERMODE_*
if (isAudibleSystemRingerMode(audioManager, systemZenMode/*, appContext*/) || (ringerMode == 0)) {

...

  -> tu zistujem ci ma zlinkovane (merged) ringing a notificartion
     vrati to:
       if (ApplicationPreferences.applicationForceSetMergeRingNotificationVolumes > 0)
         ApplicationPreferences.applicationForceSetMergeRingNotificationVolumes == 1
         - cize ak je natrdo v Settongs, ze ma zmergovane
       else
       	 ApplicationPreferences.prefMergedRingNotificationVolumes
     cize v podstate bud ak uzivatel nastavil natvrdo, ze ma zmergovane alebo a detekcia vratila, ze ma zmergovane
  if (ActivateProfileHelper.getMergedRingNotificationVolumes() &&
      ApplicationPreferences.applicationUnlinkRingerNotificationVolumes) {
    -> ma zmergovane a ma zapnuty unlink
    ...
  } else {

    -> tu zistujem ci ma zlinkovane (merged) ringing a notificartion
       vrati to:
         if (ApplicationPreferences.applicationForceSetMergeRingNotificationVolumes > 0)
           ApplicationPreferences.applicationForceSetMergeRingNotificationVolumes == 1
           - cize ak je natrdo v Settongs, ze ma zmergovane
         else
         	 ApplicationPreferences.prefMergedRingNotificationVolumes
       cize v podstate bud ak uzivatel nastavil natvrdo, ze ma zmergovane alebo a detekcia vratila, ze ma zmergovane
    if (!ActivateProfileHelper.getMergedRingNotificationVolumes()) {
     -> nie je zmergovane
      ...
      -> nastavuje hlasitost notifikacie, ale z ApplicationPreferences.prefNotificationVolume
         nastavi sa hore na zaciatku
      volume = ApplicationPreferences.prefNotificationVolume;
    }

    -> nastavuje hlasitost zvonenia, ale z ApplicationPreferences.prefRingerVolume
       nastavi sa hore na zaciatku
    volume = ApplicationPreferences.prefRingerVolume;
    -> zapisuje sa aj do servisu, NACO?
    PhoneProfilesService.getInstance().ringingVolume = volume;
  ...

  }
...

}

    static void getMergedRingNotificationVolumes(Context context) {
        synchronized (PPApplication.profileActivationMutex) {
            ApplicationPreferences.prefMergedRingNotificationVolumes =
                    ApplicationPreferences.getSharedPreferences(context).getBoolean(PREF_MERGED_RING_NOTIFICATION_VOLUMES, true);
        }
    }
    static boolean getMergedRingNotificationVolumes() {
        if (ApplicationPreferences.applicationForceSetMergeRingNotificationVolumes > 0)
            return ApplicationPreferences.applicationForceSetMergeRingNotificationVolumes == 1;
        else
            return ApplicationPreferences.prefMergedRingNotificationVolumes;
    }

Ak v Settings menim ringtone na Pixeli, meni sa STREAM_RING aj STREAM_NOTIFICATION
Ale ako pozeram, tak sa to ignoruje, tie zmeny v observeri, lebo prave aktivujem porfil.
To je to, co to ma aj robit.
Tak preco kua to na tej Xperii robi inac? Jedine mi zostava to testnut u Marta. Logovat si to.

------------------

Night mode - cize zlty film:
Pozeraj toto:
/home/henrisko/Stiahnuté/Tweaker-master/app/src/main/java/com/zacharee1/systemuituner/views/NightModeView.kt
/home/henrisko/Stiahnuté/Tweaker-master/app/src/main/java/com/zacharee1/systemuituner/services/tiles/NightModeTile.kt
/home/henrisko/Stiahnuté/Tweaker-master/app/src/main/java/com/zacharee1/systemuituner/prefs/NightModePreference.kt

Je to aplikacia SysteUI Tunner. Mas ho v S10.

--------------

Vyskusaj nahodit mobilne data s WRITE_SECURE_SETTINGS:
NEFUNGUJE :-(
boolean r1 = android.provider.Settings.Global.putInt(getContentResolver(), "mobile_data", r4) // r4 = 1 - zapnut, 0 - vypnut
boolean r1 = android.provider.Settings.Global.putInt(getContentResolver(), "mobile_data1", r5)  // r5 = 1 - zapnut, 0 - vypnut
boolean r1 = android.provider.Settings.Global.putInt(getContentResolver(), "mobile_data2", r5)  // r5 = 1 - zapnut, 0 - vypnut

--------------------

Night light (blue light filter):

Vypada to, ze takto sa to robi:

if (isActive) {
    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.N) { // API 24, ale skontroluj
        prefManager.saveOption(SettingsType.SECURE, "twilight_mode", 0)
        writeSecure("twilight_mode", 0)
    } else {
        prefManager.saveOption(SettingsType.SECURE, "night_display_activated", 0)
        writeSecure("night_display_activated", 0)
    }
} else {
    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.N) { // API 24, ale skontroluj
        prefManager.saveOption(SettingsType.SECURE, "twilight_mode", 1)
        writeSecure("twilight_mode", 1)
    } else {
        prefManager.saveOption(SettingsType.SECURE, "night_display_activated", 1)
        writeSecure("night_display_activated", 1)
    }
}

fun Context.writeSecure(key: String?, value: Any?): Boolean {
    if (key.isNullOrBlank()) return false
    return try {
        Settings.Secure.putString(contentResolver, key, value?.toString())
        true
    } catch (e: SecurityException) {
        false;
    }
}

const val TWILIGHT_MODE = "twilight_mode"
const val NIGHT_DISPLAY_ACTIVATED = "night_display_activated"
const val NIGHT_DISPLAY_AUTO_MODE = "night_display_auto_mode"
const val NIGHT_DISPLAY_COLOR_TEMPERATURE = "night_display_color_temperature"
// tiet dve este musim zistit, ci vobec vie nastavit.
// v aplikacii to nie je
const val NIGHT_DISPLAY_CUSTOM_START_TIME = "night_display_custom_start_time"
const val NIGHT_DISPLAY_CUSTOM_END_TIME = "night_display_custom_end_time"

// pre API 24
writeSecure(NightModeView.TWILIGHT_MODE, info.twilightMode)

// pre API 25+
writeSecure(NightModeView.NIGHT_DISPLAY_ACTIVATED, info.nightModeActivated)
writeSecure(NightModeView.NIGHT_DISPLAY_AUTO_MODE, info.nightModeAuto)
writeSecure(NightModeView.NIGHT_DISPLAY_COLOR_TEMPERATURE, info.nightModeTemp)

Zdroj: https://github.com/zacharee/Tweaker/blob/master/app/src/main/java/com/zacharee1/systemuituner/services/tiles/NightModeTile.kt

Bude potrebovat WRITE_SECURE_SETTINGS.
Testovane cez System UI Tuner s grantnutym WRITE_SECURE_SETTINGS na Pixel 3a.

---
Testni to potom este na Samsungu, ci to ide. Neviem, niekde som cital, ze to zhasne obrazovku
a pomoze len restart mobilu. Len neviem ci to bolo pri tomto.
!!! Hm, tak ako som pisal. Na Samsungu to zhaslo obrazovku.
!!! Aj ked zmenim len automaticke zapinanie.
!!! Takze toto urcite nemozem spravit.
!!! Ale? Mozno System UI tuner zapise len pri zmene automatiky aj to zapnutie. A to je mozno problem.
!!! Testni, testni testni.

Mozno taky test tam dat, ze nech si uzivatel skusi a za par sekund vrati, teda ak to pojde.
Vyskusaj aj to. Testuj na Galaxy S10.
Ak to vrati, tak potom to sprav tak, ze uzivatel musi cez test dako prejst. A len ak potvrdi
(najlepsie 2x) ze to nezhaslo obrazovku, tak to nastav ako povolene.

Cize sprav na to dialog s tymi 3 parametrami:
1. nemenit/zapnut/vypnut
2. automaticke zapinanie
3. teplota farby
4. Test tlacitko a len ak ho potvrdi, tak povolit OK.
   To s tym OK, to treba ten preference spravit dako inac nez obycajne.
   S pouiztim public Dialog onCreateDialog(Bundle savedInstanceState)
---

Toto je, ked to hore nepojde. Cize zavolanie Settings. Take uz mam pri nejakych parametroch profilu:

ACTION_NIGHT_DISPLAY_SETTINGS

Zdroj: https://developer.android.com/reference/android/provider/Settings#ACTION_NIGHT_DISPLAY_SETTINGS

Sprav aspon toto, lebo na Galaxy mi to hore vyplo obrazovku. :-(

------------------

EventsHandler.handleEvents()
- volane strasne vela krat zaujima ma restart udalosti a samotny orientacny senzor
- SENSOR_TYPE_DEVICE_ORIENTATION
  - z OrientationScanner.runEventsHandlerForOrientationChange() - zisti, aky thread to pouziva
  - z PPPExtenderBroadcastRecveiver.onReceive() - je to volane v HandlerThread - vroadcast treba, lebo senzor sleduje aplikacie na popredi

------------------------

sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

Orientation sensor:
Light senzor sa generuje hrozne casto. Na Samsungu donekonecna a par krat za sekundu.
Spravil som sice:
- ze sa neregistruje, ak ziadna udalost ho nepouziva
- ze sa ma handler volat az o polovicu intervalu
Ale aj tak to musi zrat vela. Kazdych 5 sekund volat eventsHandler je proste vela.
Zatial mam nenapadlo, co s tym. Do nastaveni senzora daj aspon info preference o tom ze check light zerie bateriu.

-----------------------

Vraj synchronizacia kontaktov. Testuje sa tam ContactsContract.Contacts.CONTACT_LAST_UPDATED_TIMESTAMP
A len novsie ako posledna synchronizacia (zapisat si treba cas poslednej do sharend preferences),
sa synchronizuju.
Ono to urychli synchronizaciu, to je pravda. Mozno by bolo super to takto spravit, len je to
vela prerabky celej sychronizacie kontaktov aj grup.

https://stackoverflow.com/questions/24968901/android-observer-updated-contacts

--------------------

HOTOVO. PRIDANA MOZNOST WI-FI ON/OFF CEZ "svc wifi enable".

Macrodroid ma parameter na airplane mode, ktorym sa urci, ci ma zostat wifi a bluetooth zanute.
Vypada to tak, ze airplane mod sice vypne aj wifi ale po sekunde ho zapne.
Musim zistit, ako to robi.

Pre Wifi vola:
- "svc wifi enable". Zaujimave.
Pre Bluetooth vola:
- if (bluetoothAdapter != null) { bluetoothAdapter.enable(); }

    public void mo11681y2(TriggerContextInfo triggerContextInfo) {
        boolean z = Settings.System.getInt(mo15668c0().getContentResolver(), "airplane_mode_on", 0) != 0;
        BluetoothAdapter adapter = ((BluetoothManager) mo15668c0().getSystemService("bluetooth")).getAdapter();
        boolean z2 = adapter != null && adapter.isEnabled();
        int i = this.m_state;
        boolean z3 = i != 0 ? (i == 1 || i != 2) ? false : !z : true;
        if (this.mechanismOption == 1) {
            Intent intent = new Intent("com.arlosoft.macrodropid.action.ASSISTANT");
            intent.putExtra("ACTION", "android.settings.VOICE_CONTROL_AIRPLANE_MODE");
            intent.putExtra("airplane_mode_enabled", z3);
            mo15668c0().sendBroadcast(intent);
            return;
        }
        boolean z4 = ((WifiManager) mo15668c0().getApplicationContext().getSystemService("wifi")).getWifiState() == 3;
        int a = C7384c1.m31072a("android.net.IConnectivityManager", "setAirplaneMode");
        String[] strArr = new String[1];
        StringBuilder sb = new StringBuilder();
        sb.append("service call connectivity ");
        sb.append(a);
        sb.append(" i32 ");
        String str = "1";
        sb.append(z3 ? str : "0");
        strArr[0] = sb.toString();
        C5306q1.m22879n0(strArr);
        String[] strArr2 = new String[2];
        StringBuilder sb2 = new StringBuilder();
        sb2.append("settings put global airplane_mode_on ");
        if (!z3) {
            str = "0";
        }
        sb2.append(str);
        strArr2[0] = sb2.toString();
        StringBuilder sb3 = new StringBuilder();
        sb3.append("su -c am broadcast -a android.intent.action.AIRPLANE_MODE --ez state ");
        sb3.append(z3 ? "true" : "false");
        strArr2[1] = sb3.toString();
        C5306q1.m22879n0(strArr2);

        if (this.m_keepWifiOn && z4) {
TOTO ZAPNE WIFI
            new Handler(mo15668c0().getMainLooper()).postDelayed(new C3530gc(this), 1000);
        }
        if (this.m_keepBluetoothOn && z2) {
TOTO NETREBA, PPP VIE ZAPNUT BLUETOOTH AJ PRI AIRPLANE MODE ON
            new Handler(mo15668c0().getMainLooper()).postDelayed(new C3469ec(adapter), 1000);
        }
    }

/home/henrisko/Stiahnuté/MacroDroidDeviceAutomation_v5.17.3_apkpure.com_source_from_JADX/sources/com/arlosoft/macrodroid/action/SetAirplaneModeAction.java
matoda: mo11681y2()

Wifi - class C3469ec
   public final void run() {
        SetAirplaneModeAction.m16576Y2(this.f7644a);
    }

Bluetooth - Class: C3530gc.java
 /* renamed from: Y2 */
    static /* synthetic */ void m16576Y2(BluetoothAdapter bluetoothAdapter) {
        if (bluetoothAdapter != null) {
            bluetoothAdapter.enable();
        }
    }

---

Mozno by som mohol to spravit tak, ze ak je airplane mode zapnuty, pouizje v
ActivateProfileHelper.doExecuteForRadios() namiesto wifiManager.setWifiEnabled, "svc wifi enable".
Ale podla mna to vyzaduje root. Tak ako pri "Mobile data". Cize parameter "Wi-Fi" bude mat este
jeden item "(R) On in airolane mode", "(R) off in airplane mode", "(R) Togghe in airplane mode".
To sa mi paci. :-)

Ako zistim, ci je zapnuty airplne mod. Len vtedy pouzijem svc wifi enable/disable:
public static boolean isAirplaneModeOn(Context context) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return Settings.System.getInt(context.getContentResolver(),
                Settings.System.AIRPLANE_MODE_ON, 0) != 0;
    } else {
        return Settings.Global.getInt(context.getContentResolver(),
                Settings.Global.AIRPLANE_MODE_ON, 0) != 0;
    }
}

-------------------

Senzor na detekciu, ci je tel.cislo v roamingu.
Vraj na to staci PhonePstaeListener. Ten mam a regustujem ho cez:
PhoneProfilesService.registerPhoneCallsListener();
Volane v PhoneProfilesService.registerAllTheTimeRequiredSystemReceivers().

Kedze je to v AllTheTime, ma to uz zaregistovanie vzdy.
Staci pridat toto:

Toto musis pridat, mas tam len PhoneStateListener.LISTEN_CALL_STATE. Cez oparator |:
PhoneStateListener.LISTEN_SERVICE_STATE;

A potom v samotnom listeneri treba pridat novu metodu:

   @Override
    public void onServiceStateChanged(ServiceState serviceState) {
        super.onServiceStateChanged(serviceState);
        if (serviceState.getRoaming()) {
            // In Roaming
        } else {
            // Not in Roaming
        }
    }

Este je monzost cez SubscriptionManager (pre dual sim), ale tu detekciu cez listener treba tak ci tak:
"With Android 5.1 update, there is now a very easy roaming detection: just use the SubscriptionManager
and get a roaming info from SubscriptionInfo getDataRoaming(). If there are multiple SIMs, only the info
from active one is returned, which is convenient."
Toto je ale len pre roaming dat. Takze asi TelephopnyManmager bude lepsi.
Cez neho je mozne ziskat, ci je mobil v roamingu alebo ci jeho data su v roamingu:

pridal som tieto dve premenne:
    boolean networkRoaming;
    boolean dataRoaming;
citaj v doHandleEvent() z:
    Z PPApplication:
    static PhoneCallsListener phoneCallsListenerSIM1 = null;
    static PhoneCallsListener phoneCallsListenerSIM2 = null;
    static PhoneCallsListener phoneCallsListenerDefaul = null;
Podpora pre dual sim musi byt od API 26. Tak ako pri "Call sensor".

A samozrejme potom este novy senzor do udalosti pre toto.

ASI NETREBA, VOLANE onServiceStateChanged() NA ZACIATKU
Treba na zaciatku v doForFirstStart() testnut, ci je v mobil roamingu. Takze sprav to ako mas hore v
onServiceStateChanged() a pouzi na to tieto globalne premmene v PPApplication:
    static TelephonyManager telephonyManagerSIM1 = null;
    static TelephonyManager telephonyManagerSIM2 = null;
    static TelephonyManager telephonyManagerDefault = null;
Pouzi na ziskanie ServiceState toto: TelephonyManager.getServiceState().
ALE BACHA, JE LEN OD API 26. Takze pre nizsie api nebude v senzore ziskanie data roamingu.
Pre API < 26 pouzi len toto (ziskanie network roamingu z TelephonyManager):
    if (telephonyManager.isNetworkRoaming()) {
        // In Roaming
    } else {
        // Not in Roaming
    }

V emulatore si mozem zapnut roaming, takze mozem testovat ;-)
Funfuje v api 24, v 32 neslo. Tak testuj.

Zdroj: https://stackoverflow.com/questions/28386553/check-if-a-vpn-connection-is-active-in-android

-----------------------

